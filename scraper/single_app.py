# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J4jmBk30-Z0ekgO2TNKbJTdSzlBxh-CO
"""

import requests
from bs4 import BeautifulSoup
from bs4 import Tag
import pandas as pd
from datetime import datetime
import time  # Added to prevent rate limiting

def extract_rating(review):
    """Extract star rating from review"""
    rating_div = review.find('div', class_='tw-flex tw-relative tw-space-x-0.5 tw-w-[88px] tw-h-md')
    if rating_div and 'aria-label' in rating_div.attrs:
        aria_label = rating_div['aria-label']
        try:
            return aria_label.split(' ')[0]
        except IndexError:
            return None
    return None

def parse_review_date(date_str):
    """Convert Shopify date format into a Python datetime object"""
    if 'Edited' in date_str:
        date_str = date_str.split('Edited')[1].strip()
    else:
        date_str = date_str.split('Edited')[0].strip()
    try:
        return datetime.strptime(date_str, '%B %d, %Y')
    except ValueError:
        return None

def fetch_reviews(app_url, app_name, start_date, end_date, debug):
    """Fetch reviews directly for the specified app"""
    base_url = app_url.split('?')[0]
    page = 1
    reviews = []

    while True:  # Keep fetching until old reviews are encountered
        print(f"Fetching page {page} for {app_name}...")
        reviews_url = f"{base_url}/reviews?sort_by=newest&page={page}"
        response = requests.get(reviews_url)
        soup = BeautifulSoup(response.content, 'html.parser')

        # Updated review container class (Shopify structure update)
        review_divs = soup.find_all("div", attrs={"data-merchant-review": True})
        print(f"🔹 Found {len(review_divs)} reviews on page {page}")

        if not review_divs:  # If no reviews are found, break the loop
            print('❌ No more reviews found. Stopping.')
            break

        has_recent_reviews = False

        for review_div in review_divs:
            review_text_div = review_div.find('div', {'data-truncate-content-copy': True})
            review_text = review_text_div.find('p').text.strip() if review_text_div else "No review text"

            reviewer_name_div = review_div.find('div', class_='tw-text-heading-xs tw-text-fg-primary tw-overflow-hidden tw-text-ellipsis tw-whitespace-nowrap')
            reviewer_name = reviewer_name_div.text.strip() if reviewer_name_div else "No reviewer name"

            reviewer_and_location_div = reviewer_name_div.parent
            reviewer_and_location_div_children = [child for child in reviewer_and_location_div.contents if isinstance(child, Tag)]
            location = reviewer_and_location_div_children[1].text.strip() if len(reviewer_and_location_div_children) > 1 else 'N/A'
            duration = reviewer_and_location_div_children[2].text.strip() if len(reviewer_and_location_div_children) > 2 else 'N/A'

            if duration.endswith(' using the app'):
                duration = duration[:-len(' using the app')]

            review_date_div = review_div.find('div', class_='tw-text-body-xs tw-text-fg-tertiary')
            review_date_str = review_date_div.text.strip() if review_date_div else "No review date"

            rating = extract_rating(review_div)
            review_date = parse_review_date(review_date_str)

            if review_date > start_date:
                # Skip reviews that are newer than start_date
                has_recent_reviews = True
            elif review_date and start_date >= review_date >= end_date:
                # Filter reviews based on date range
                reviews.append({
                    'app_name': app_name,
                    'review': review_text,
                    'reviewer': reviewer_name,
                    'date': review_date_str,
                    'location': location,
                    'duration': duration,
                    'rating': rating
                })
                has_recent_reviews = True
            else:
                print(f"🛑 Review too old: {review_date_str}. Stopping.")
                break  # Stop scraping if we reach an older review

        if not has_recent_reviews:
            print('✅ All recent reviews collected.')
            break

        page += 1  # Go to the next page

        time.sleep(1)  # ✅ Prevents rate limiting by adding a delay

    return reviews

# Direct App URL
base_url = 'https://apps.shopify.com/marketplace-connect?surface_intra_position=7&surface_type=partners&surface_version=redesign'

# Date Range for Reviews
start_date = datetime(2025, 5, 8)
end_date = datetime(2017, 5, 1)
DEBUG_MODE = False

def main():
    """Main function to fetch reviews for the specific app"""
    app_name = "Shopify Marketplace Connect"
    reviews = fetch_reviews(base_url, app_name, start_date, end_date, DEBUG_MODE)

    print(reviews)

    data = []
    for review in reviews:
        row_data = {
            'app_name': review.get('app_name', 'No App Name'),
            'review': review.get('review', 'No Review'),
            'reviewer': review.get('reviewer', 'No Reviewer'),
            'date': review.get('date', 'No Date'),
            'rating': review.get('rating', 'No Rating'),
            'duration': review.get('duration', 'No Duration'),
            'location': review.get('location', 'No Location'),
        }
        data.append(row_data)

    if DEBUG_MODE:
        print(data)
    else:
        df = pd.DataFrame(data)
        now = datetime.now()
        csv_file_path = f'shopify_app_reviews_{now.strftime("%Y%m%d")}.csv'
        df.to_csv(csv_file_path, index=False, encoding='utf-8')

    print("✅ Data has been written to shopify_app_reviews.csv")

if __name__ == '__main__':
    main()

